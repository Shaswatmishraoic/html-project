<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML Project</title>
  <link rel="shortcut icon" href="./logo.webp" type="image/x-icon" />
</head>

<body>
  <h1>Backtracking</h1>
  <span style="color: gray"> Backtracking is a from of recursion.</span>
  <br />
  <br />
  <p style="color: gray">
    The usual scenario is that you are faced with a number of options, and you
    must choose one of these. After you make your <br />
    choice you will get a new set options, just what set of options you get
    depends on what choice you made. This procedure is <br />
    repeated over and over unit you reach a final state. If you made a good
    sequence of choices, your final state is a goal state; if <br />
    you didn't, it isn't.
  </p>
  <br />
  <p style="color: gray">
    Conceptually, you start at the root of a tree; the tree probably has some
    good leaves, though it may be that <br />
    the leaves are all good or all bad. YOu want to get to a good leaf. At
    each node, beginning with the root, you choose one of its <br />
    children to move to and you keep this up until you get to a leaf.
  </p>
  <br />
  <p style="color: gray">
    Suppose you get to a bad leaf. You can backtracking continue the the
    search for a good leaf by revoking your most recnt choice, <br />
    and trying out the next option in that set of option. If you run out of
    option, revoke the choice that got you here, and try <br />
    another choice at that at that node. If you end up at the root with no
    options left, there are no good leaves to be found.
  </p>
  <br />
  <span style="color: gray">This needs an example</span><br />
  <img src="./Image_root.png" alt="root" /><br />
  <ol type="1" style="color: gray">
    <li>Start at Root, your option are A and B. You choose A.</li>
    <br />
    <li>At A, your option are C and D. You choose C.</li>
    <br />
    <li>C is bad. Go back to A.</li>
    <br />
    <li>At A, you have already tried C, and it failed. Try D.</li>
    <br />
    <li>D is bad. Go back to A.</li>
    <br />
    <li>At A, you have no option left to try. Go back to Root.</li>
    <br />
    <li>At Root, you have alreay tried A. Try B.</li>
    <br />
    <li>At B, your option are E and F. Try E.</li>
    <br />
    <li>E is good Congratulation!</li>
  </ol>
  <br />
  <p>
    In this example we drew a picture of a tree. The tree is an abstract model
    of the possible sequences of choices we could <br />
    make. There is also a data structure called a tree, but usually we don't
    have a data structure to tell us what choices we <br />
    have. (If we do have an actual tree data structure , backtracking on it is
    called depth-first tree searching.)
  </p>
  <hr />
  <h3><b>The backtracking algorithm.</b></h3>
  <div>
    <pre style="color: blue">
        boolean solve(Node n){ 
            if n is a leaf node{ 
            if the leaf is a goal node, return true 
            else return false 
        } else { 
            for each child c of n { 
                if solve(c) succeeds, return true 
            } 
            return false 
           } 
        } </pre>
  </div>
  <p style="color: gray">
    Notice that the algorithm is expressed as a boolean function. This is
    essential to understanding the algorithm. If <br />
    solve(n) is true, that means node n is part of a solution -- that is, node
    n is one of the nodes on a path from the root to <br />
    some goal node. We say that n is solvable. If solve(n) is false, then
    there is no path that includes n to any goal node.
  </p>
  <br />
  <b>How does this work?</b> <br />
  <ul style="color: gray">
    <li>If any child of n is solvable, then n is solvable.</li>
    <li>If no child of n is solvable, then n is not solvable.</li>
  </ul>
  <br />
  <p style="color: gray">
    Hence, to decide whether any non-leaf node n is solvable (part of a path
    to a goal node), all you have to do is test whether any <br />
    child of n is solvable. This is done recursively, on each child of n. In
    the above sode, this is done by the lines.
  </p>
  <pre style="color: blue">
    for each child c of n {
      if solve(c) succeeds, return true
    }
     return false
    </pre>
  <p style="color: gray">
    Eventually the recursion will "bottom" out at a leaf node. If the leaf
    node is a goal node, it is solvable; if the leaf node is not a goal <br />
    node, it is not solvable. This is out base case in the above code this is
    done by the lines.
  </p>
  <pre style="color: blue">
    if n is a leaf node{
      if the leaf is a goal node, return true
    else return false
    }</pre>
  <span style="color: gray">The backtracking algorithm is simple but important. YOu shoul understand
    it throughly. Another way of starting it is as follows:
  </span>
  <br />
  <ul>
    <li><b>To search a tree:</b></li>
  </ul>
  <ol style="color: gray">
    <li>
      If the tree consists of a single leaf, test whether it is a goal node.
    </li>
    <li>
      Otherwise, search the subtrees until you find one containing a goal
      node, or until you have <br />
      searched them all unsuccessfully.
    </li>
  </ol>
  <br />
  <h3><b>Non-recirsive backtracking, using a stack</b></h3>
  <p style="color: gray">
    Backtracking is a rather typical recursive algorithm and any recurive
    algorithm can be rewritten as a stack algorithm. In fact, <br />
    that is how your recursive algorithms are translated into machine or
    assembly language.
  </p>
  <pre style="color: blue">
  boolean solve(Node n){
     put node n on the stack;
     while the stack is not empty{
      if the node at the top of the stack is a leaf {
        if it is a goal node, return true
          else pop it off the stack
      } 
       else{
        if the node at the top of the stack has untried children
        push the next untried child on to the stack
      else pop the node off the stack
       }
        return false
      }}
       </pre>
  <p style="color: gray">
    Starting from the root, the only nodes that can be pushed onto the stack
    are the children of the node currently on the top of the <br />
    stack, and these are only pushed on one child at a time; hence, the nodes
    on the stack at all times describe a valid path in the <br />
    tree. Nodes are removed from the stack only when it is known that they
    have no goal nodes among their descendents. Therefore, <br />
    problem.
  </p>
  <br />
  <p style="color: gray">
    When the stack algorithm terminates successfully the nodes on the stack
    form(in reverseorder) a path from the root to a goal <br />
    node.
  </p>
  <br />
  <p style="color: gray">
    Similarly, when the recursive algorithm finds a goal nodes, the path
    information is embodied(in reverse order) inthe sequence of <br />
    recursive calls. Thus as the recursion unwinds, the path can be recovered
    one node at a time, by(for instance) printing the node <br />
    at the current level, or storing it in an array. <br />
    <br />
    Here is the recurive backtracking algorithm, modified slightly to print(in
    reverse order) the nodes along the successful path:
  </p>
  <pre style="color: blue">

boolean solve(Node n){
  if n is a leaf node {
    if the leaf is a goal node{
      print n 
      return true 
    }
  else return false 
  } else{
    for each child c of n{
      if solve(c) succeeds{
        print n 
      return true
      }}
    return false
     }
}</pre>
  <h3>Keeping backtracking simple</h3>
  <p style="color: gray;">All of these versions of the backtracking algorithmare pretty simple, but when applied to a
    real problem, they can get pretty <br>
    cluttered up with details. Even determining whether the node is a leaf can be complex: <br>
    <br>
    for example, if the path represents a series of moves in a chess endgame problem, the leaves are the checkmate and
    stalemate <br>
    solution <br> <br>
    To keep the program clean, therefore, test like this should be buried in methods. In a chess game, for example, you
    could test <br>
    whether a node is a leaf by writing a <b style="color: black;">gameOver method</b> (or you could even call it <b
      style="color: black;">isLeaf)</b>. This method would encapsulate all the <br>
    <br>
    Notice that the backtracking algorithm require us to keep track for each node on the current path, which of its
    children have <br>
    been tried already (so we don't have to try them again). In the above code we made this look simple, by just saying
    <b style="color: black;">for each child <br>
      c of n.</b> In reality, it may be difficult to figure out what the possible children are and there may be no
    obvious way to step though <br>
    them. In chess, for example a node can represent one arrangement of pieces on a chessboard, and each child of that
    node can <br>
    represent the arrangementafter some piece has made a legal move. How do you find these children, and how do you keep
    track <br>
    of which ones you've already examined? <br>
    <br>
    The most straightforward way to keep track of which children of the node have been tried is as follows: Upon initial
    entry to the <br>
    node (that is, when you first get there from above), make a list of all its children. As you try each child, take it
    off the list. When <br>
    the list is empty, there are ni remaining untried children, and you can return "failure". This is a simple approach,
    but it may require <br>
    quite a lot of additional work. <br>
    <br>
    There is an easier way to keep track of which children have been tried, if you can define an ordering on the
    children. If there is an <br>
    ordering, and you know which child you just tried , you can determine which child to try next. <br>
    <br>
    For example, you might be able to number the <b style="color: black;">children 1 through n,</b> and try them in
    numerical order. Then, if you have just tried <br>
    <b style="color: black;">child k,</b> you know that you have already tried children 1 through <b
      style="color: black;">k-1,</b> and you have not yet tried children <b style="color: black;">k+1</b> through <b
      style="color: black;">n.</b> Or if you <br>
    are trying to color a map with just four colors. you can always try <b style="color: black;">red first, then yellow,
      then green, then blue.</b> If child yellow fails, <br>
    you know to try child green next. If you are searching a maze, you can try choices in the order left, straight,
    right <b style="color: black;">(or perhaps <br>
      north, east, south, west).</b><br>
    <br>
    It isn't always easy to find a simple way to order the children of a node. <b style="color: black;">In the game
      example,</b> you might number your <br>
    pieces (or perhaps the sqares of the board) and try them in numerical order; but in addition each piece may also
    have several <br>
    moves, and these must also be ordered.
    <br> <br>
  <h2>Example: Tree search</h2>
  <br>
  <span style="color: gray;"> For starters, let's do the simplest possible example of backtracking, which is searching
    an actural tree. We will also use the <br>
    simplest kind of tree, a binary tree.</span><br>
  <br>
  <span style="color: gray;">A binary tree is a data structure composed of nodes. One node is designated as the root
    node. Each node can reference (point <br>
    to) zero, one or two other nodes, which are called its children. The children are referred to as the left child
    and/or the right child. <br>
    All nodes are reachable (by one or more steps) from the root node, and there are no cycles. For our purposes,
    although this is not <br>
    part of the definition of a binary tree, we will say that a node might or might not be a goal node, and will contain
    its name. The <br>
    frist example in this paper (ehich we repeat here) shows a binary tree. </span><br>
  <br>
  <span style="color: gray;">Here's a definition of the BinaryTree class</span>
  </p>
  <pre style="color: blue;">
  public class BinaryTree{
    BinaryTree leftChild = null;
    BinaryTree rightchild = null;
    boolean isGoalNode = false;
    String name;

    BinaryTree (String name, BinaryTree left, BinaryTree right, boolean isGoalNode){
      this.name = name;
      leftChild = left;
      rightChild = right;
      this.isGoalNode = isGoalNode;
    }
  }
</pre>
  <span style="color: gray;">Next we will create a TreeSearch class and in it we will define a method makeTree() which
    constructs the above binary tree. </span>
  <pre style="color: blue;">
  static BinaryTree make Tree(){
    BinaryTree root a, b, c, d, e, f;
  c= new BinaryTree("C", null, null, false);
  d= new BinaryTree("D", null, null, false);
  e= new BinaryTree("E", null, null, true);
  f= new BinaryTree("F", null, null, false);
  a= new BinaryTree("A", c, d, false);
  b= new BinaryTree("B", e, f, false);
  root= new BinaryTree("Root", a, b, false);
  }</pre>
  <span style="color: gray;">Here's a main program to create a binary tree and try to solve it:</span><br>
  <pre style="color: blue;">
  public static void main(String arg[]){
    BinaryTree = makeTree();
    System.out.println(solvable(tree));
  }</pre>
  <span style="color: gray;">And finally, here's the recursive backtracking routine to "solve" the binary tree by
    finding a goal node</span>
  <pre style="color: blue;">
  static boolean solvable(Binary Tree node){
    /*1*/ if (node ==null) return false;
    /*2*/ if(node.isGoalNode) return true;
    /*3*/ if (solvable(node.leftchild)) return true;
    /*4*/ if (solvable(node.rightchild)) return true;
    /*5*/ return false;
    }  </pre>
  <p style="color: gray;">Here's what the numbered lines are doing:
  <ol type="1" style="color:gray;">
    <li>If we given a null node, it's not solvable. This statement is so that we can call this method with the children
      of a node, without be
      first checking whether those children actually exist.
    </li>
    <li>If the node we are given is a goal node, return success.</li>
    <li> See if the left child of node is solvable and if so, conclude that node is solvable. We will only get to this
      line if node is non-null be
      andis not a goal node, say to
    </li>
    <li>Do the same thing for the right child.</li>
    <li>Since neither child of node is solvable node itself is not solvable.</li>
  </ol>
  <span style="color: gray;"> This program runs correctly and produces the unenlightening result true. </span><br>
  <br> <span style="color: gray;">
    Each time we ask for another node, we have to check it is null in the above we put that check as the first thing in
    solvable. An <br>
    alternative would be to check first whether each child exists and recur only ifthey do. Here's that alternative
    version. </span></p>
  <pre style="color: blue;">
static boolean solvable(Binary Tree node){
  if(node.isGoalNode) return true;
  if (node.leftChild != null && solvable(node.leftChild)) return true;
  if (node.rightChild != null && solvable(node.rightChild)) return true;
return false;
}</pre>
  <span style="color: gray;">I think the first version is simple, but the second version is slightly more
    efficient.</span>
  <hr>
  <h2>What are the children? </h2>
  <br>
  <p style="color: gray;">One of the things that simplifies the above binary tree search is that, at each choice point,
    you can ignore all the previous <br>
    choices. Previous choices don't give you any information about what you should do next, as far as you know both the
    left and the <br>
    right child are possible solutions in many problem however you may be able to eliminate children immediately ,
    without <br>
    recursion. <br>
    <br>
    Consider for example the problem of four-coloring a map. It is a theorem of mathematics that any map on a plane, no
    matter <br>
    how convoluted the countries are, can be colored with at most four colors, so that no two countries that share a
    border are the <br>
    same color. <br>
    <br>
    To color a map, you choose a color for the first country, then a color for the second country and so on, until all
    countries are <br>
    colored. <br>
    <br>
    There are two ways to do this: <br>
  <ul>
    <li>Method 1. Try each of the four possible colors, and recur. When you run out of countires, check whether you are
      at a goal node.</li>
    <li>Method 2. Try only those colors that have not already been used for an adjacent country, and recur. If and when
      you run out of <br>
      countries, you have successfully colored the map.</li>
  </ul>
  <br>
  Let's apply each of these two methods to the problem of coloring a checkerboad. This should be easily solvable; after
  all a <br>
  checkerboad only needs two colors. <br>
  <br>
  <b style="color: black;">boolean maplsOK()</b><br>
  <span style="color: gray;">Used by method 1 to check (at a leaf node) whether the entire map is colored
    correctly.</span><br>
  <b style="color: black;">boolean okToColor(int row, int column, int color)</b><br>
  <span style="color: gray;">Used by method 2 to check, at every node, whether there is an adjacent node already colored
    with the given color</span><br>
  <b style="color: black;">int[] nextRowAndColumn(int row, int column)</b><br>
  <span style="color: gray;">Used by both methods to find the next country (actually, the row and column of the next
    square on the checkerboard).</span><br>
  <br>
  Here's the code for method1:
  </p>
  <pre style="color: blue;">
  boolean explore1 (int row, int column, int color) {
    if (row >= NUM_ROWS) return maplsOK();
    map[row][column] = color;
    for (int nextColor = RED; nextColor <= BLUE; nextColor++) {
    int[] next = nextRowAndColumn(row, column);
    if (explore1(next[0], next[1], nextColor)) return true;
    }
    return false;
    }
</pre>
  <br>
  <span style="color: gray;">And here's the code for method 2:</span>
  <pre style="color: blue;">
  boolean explore2(int row, int column, int color) {

    if (row> NUM_ROWS)return true;
    
    if (okToColor(row, column, color)) {
    
    map[row][column] = color;
    
    for (int nextColor = RED; nextColor <= BLUE; nextColor++) {
    
    int[] next = nextRowAndColumn(row, column);
    
    if (explore2(next[0], next[1], nextColor))
     return true;
      }
    }
    
    return false;
    }
</pre>
  <p style="color: gray;">Those appear pretty similar, and you might think they are equally good. However, the timing
    information suggests otherwise: <br>
    <center>
      <table border="1">
        <tr>
          <th></th>
          <th bgcolor="gray">2 by 3 map</th>
          <th bgcolor="gray">3 by 3 map</th>
          <th bgcolor="gray">3 by 4 map</th>
        </tr>
        <tr>
          <th bgcolor="gray">Method 1:</th>
          <td>60 ms.</td>
          <td>940 ms.</td>
          <td>60530 ms.(1 minute)</td>
        </tr>
        <tr>
          <th bgcolor="gray">Method 2:</th>
          <td>0 ms.
          </td>
          <td>0 ms.</td>
          <td>0 ms</td>
        </tr>
      </table>
    </center>
    <span style="color: gray;">The zeros in the above table indicate times too short to measure (less than 1
      millisecond). Why this huge difference? Either of <br>
      these methods could have exponential growth. Eliminating a node automatically eliminates all of its descendents,
      and this will <br>
      often prevent exponential growth. Conversely, by waiting to check until a leaf node is reached, exponential growth
      is practically <br>
      guaranteed. If there is any way to eliminate children (reduce the set of choices), do so! <br>
    </span>
    <hr>
  <h3 style="color: black;">Debugging techniques</h3>
  <span style="color: gray;">
    Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful, but sometimes we need
    to fall <br>
    back on inserting print statements. There are some simple tricks to making effective use of print statements. These
    tricks can be <br>
    applied to any program, but are especially useful when you are trying to debug recursive routines.
  </span><br><br>
  <b style="color: black;">Trick #1: Indent when you print method entries and exits.
  </b><br><br>
  <span style="color: gray;">Often, the best debugging technique is to print every method call and return (or at least
    the most important ones) You probably <br>
    want to print, for each method, what parameters it came in with, and what value it leaves with However, if you just
    print a long <br>
    list of these, it's hard to match up method exits with their corresponding entries. Indenting to show the level of
    nesting can help.</span><br><br>
  <b style="color: black;">Trick #2: Use specialized print methods for debugging.</b><br><br>
  <span style="color: gray;">Don't clutter up your actual code more than you must. Also, remember that code inserted for
    debugging purposes can itself <br>
    contain bugs, or (in the worst case) can affect the results, so be very careful with it. <br>

    Here's our debugging code For this trivial program, there's almost more debugging code than actual code, but in
    larger programs <br>
    the proportions will be better.</span>
  <pre style="color: blue;">
    static String indent
    static String name(BinaryTree node) { if (node == null) return null;Â 
      else return node.name;
    static void enter (Binary Tree node) {
    System.out.println(indent+ "Entering solvable("+name(node) + ")");
    indent = indent + "|";
    }
    static boolean yes(BinaryTree node) { indent = indent.substring(3);
    System.out.println(indent + "solvable("+name(node) + ") returns true");
    return true;
    static boolean no(Binary Tree'node) { Indent = indent.substring(3), System.out.println(indent solvable(" name(node)+") returns false");
    return false;
    }</pre>
  <span style="color: gray;">To use this code, we modify solvable as follows:</span><br>
  <pre style="color: blue;">
      static boolean solvable (BinaryTree node) {

        enter(node);
        
        if (node == null) return no(node);
        
        if (node.isGoalNode) return yes(node);
        
        if (solvable(node.leftChild)) return yes(node); return no(node);
        
        if (solvable(node.rightChild)) return yes(node);
        }</pre>
  <pre style="color: gray;">
          And we get these results:

          Entering solvable(Root)
          
          | Entering solvable(A)
          
          || Entering solvable(C)
          
          ||| Entering solvable(null)
          
          ||| solvable(null) returns false
          
          ||| Entering solvable(null)
          
          ||| solvable(null) returns false
          
          ||| solvable(C) returns false
          
          || Entering solvable(D)
          
          ||| Entering solvable(null)
          
          ||| solvable(null) returns false
          
          ||| Entering solvable(null)
          
          ||| solvable(null) returns false
          
          || solvable(D) returns false
          
          | solvable(A) returns false
          
          | Entering solvable(B)
          
          ||Entering solvable(E)
          
          ||solvable (E) returns true
          
          |solvable(B) returns trug
          
          solvable Root returns true
          
          true</pre>
          <b style="color: black;">Trick #3: Never discard your debugging statements.</b><br><br>
          <span style="color: gray;">Writing debugging statements is programming, too. Often it's as much work to debug the debugging statements as it is to debug <br>
             the actual program. Once your program is working, why throw this code away?<br>

            Obviously, you don't want to print out all this debugging information from a program you are ready to submit (or to turn over to <br>
             your manager). You could comment out your debugging calls, but that can be a lot of work. What's more, in the above example, <br>
              you would have to replace every return(yes(node)) with return(true), and every return(no(node)) with return false. With all these <br>
               changes, you might introduce new bugs into your program. <br>
            <br>
            The simple solution is to make your debugging statements conditional. For example,</span>
<pre style="color: blue;">
  static final boolean debugging = false;
  static void enter (Binary Tree node) 
  {4159-9614-1650b48b42bd-bad8/if (debugging) 
  {System.out.println(indent + "Entering solvable(" + name(node) + ")");
   indent indent+" "static boolean yes (BinaryTree node)
  {if (debugging) {indent indent.substring(3); 
  System.out.println(indent + "solvable(" + name(node) + ")returns true");
    return true;static boolean no(Binary Tree node)
     {if (debugging) [indent = indent.substring(3);System.out printinfindent "solvable(" + name(node)+ ")returns false");
         }
        return false;
         }
            </pre>        
  </p>
  <span style="color: gray;">
    n industry, actual programs often have multiple flags to control different aspects of debugging. Don't worry too much <br>
     about making your code larger, modern compilers will notice that since the variable debugging is final, it can never be true, and the <br>
      controlled code will be discarded.</span> <br><br>
      <b style="color: black;">
        Trick #4: Create an Exception.</b><br> <br>
 <span style="color: gray;">If an Exception is thrown, you can get information about just where it happened by sending it the message <br>
   printStackTrace(PrintStream). Since an Exception is an object like any other, you can create and throw your own Exceptions. <br>
    However, Java programmers don't always realize that you can create an Exception without throwing it. For example, the following <br>
     code.</span>
     <pre style="color: blue;">new Exception("Checkpoint Charlie").printStackTrace(System.out);</pre>
     <span style="color: gray;">will print out a message something like this, and the program will then continue normally That is, the above code just acts like abr
       print statement.</span>
<pre style="color: blue;">
  java.lang.Exception: Checkpoint Charlie
  at TreeSearch.solvable(TreeSearch.java:53)
  at TreeSearch.solvable(TreeSearch.java:57)
  at TreeSearch.main(TreeSearch.java:72)
  at SHELL38.run(_SHELL38.java:16)
  at bluej.runtime.ExecServer.suspendExecution(Unknown Source)</pre>
<hr>
<h3>Example: Cindy's Puzzle</h3>
<span style="color: gray;">
  I call the following puzzle "Cindy's puzzle" for historical reasons. You have some number n of black marbles and the same number <br>
   of white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the marbles in. Start with <br>
    the black marbles all at one end (say, the left), the white marbles all at the other end, and a free space in between.</span>
    <center>
      <table border="1" bgcolor="gray" cellpadding="8">
<td><img src="./black-ball.png" alt="ball"></td>
<td><img src="./black-ball.png" alt="ball"></td>
<td width="45"></td>
<td><img src="./white-ball.png" alt="ball"></td>
<td><img src="./white-ball.png" alt="ball"></td>
      </table>
    </center> <br>

    <span style="color: gray;">The goal is to reverse the positions of the marbels:</span><br>
    <center>
      <table border="1" bgcolor="gray" cellpadding="8">
        <td><img src="./white-ball.png" alt="ball"></td>
        <td><img src="./white-ball.png" alt="ball"></td>
        <td width="45"></td>
        <td><img src="./black-ball.png" alt="ball"></td>
        <td><img src="./black-ball.png" alt="ball"></td>
      </table>
    </center> <br>
    <br>
    <b>The black marbels can only move to the right, and the white marbles can only move to the left (no backing up) At each move, a <br>
    marble can either: </b>
    <ul style="color: gray;">
      <li>Move one space ahead, if that space is clear, or</li>
      <li>Jump ahead over exactly one marble of the oppsite color, if the space just beyond that marble is clear.</li>
    </ul>
    <br>
    <span style="color: gray;"> For example, you could make the following sequence of moves.</span>
    <br>
  <center>
    <table cellpadding="8">
      <tr>
        <td>
          <b>starting position:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td width="45"></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Black moves a head:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td><img src="./black-ball.png" alt=""></td>
              <td width="45"></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>White jumps:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td width="45"></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Black moves ahead:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td width="45"></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Black jumps:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td width="45"></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>White moves ahead:</b>
        </td>
        <td>
          <table border="1" cellpadding="8" bgcolor="gray">
            <tr>
              <td width="45"></td>
              <td><img src="./white-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./black-ball.png" alt=""></td>
              <td><img src="./white-ball.png" alt=""></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <b>Stuck!</b>
        </td>
    </table>
  </center><br>
  <p style="color: gray;">
    The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf, <br>
     which in this case means a position from which no further moves are possible. This isn't so easy. <br>
     <br>
     Now to the program. The main program will initialize the board, and call a recursive backtracking routine to attempt to solve the <br>
      puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, and the main program will have to <br>
      print out the bad news. <br>
      <br>
      The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf, <br>
       which in this case means a position from which no further moves are possible. This isn't so easy. <br>
       <br>
       Each possible move will result in a new board position, and these new board positions are the children of the current board position. <br>
        Hence to find the children of a node (that is, of a board position), we need only find the possible moves from that node. <br>
         Remember that it is also highly desirable to find an ordering on these possible moves. <br>
    <br>
    Here it is time to stop and take thought To make progress, we must analyze the game to some extent. Probably a number of <br>
     approaches would work, and what follows is based on the way worked it out if you were to program this puzzle, you might find <br>
      a different but equally valid approach. <br>
    <br>
    First, notice that if a marble has a move, that move is unique: if it can move ahead one square, then it cannot jump. <br>
     If it can jump, it cannot move ahead one square. This suggests that, to find the possible moves, we might assign numbers to the marbles, and <br>
      check each marble in turn. When we have looked at all the marbles, we have looked at all the possible moves. This would require <br>
       having a table to keep track of where each marble is, or else somehow "marking" each marble with its number and searching the <br>
        board each time to find the marble we want. Neither alternative is very attractive. <br>
        <br>
        Next, notice that for a given board position, each marble occupies a unique space. Hence, instead of talking about moving a <br>
         particular marble, we can talk about moving the marble in a particular space. If a move is possible from a given space, then that <br>
          must be the only move possible from that space, because if the marble in that space has a move, it is unique. There is a slight <br>
           complication because not every space contains a marble, but at least the spaces (unlike the marbles) stay in one place. <br>
           <br>
           <b style="color: black;">
            Now we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. For each <br>
             space, either zero or one moves is possible. With this understanding, we can write a boolean method canMove(int[] board, int <br>
              position) which determines whether a move is possible from the given position: <br>
           </b> <br>
        <ul style="color: gray;">
          <li>If the position is empty, no move is possible;
          </li>
          <li>If the position contains a black marble, the method checks for a move or jump to the right; </li>
          <li>If the position contains a white marble, the method checks for a move or jump to the left.</li>
        </ul>  <br>
       <span style="color: gray;"> We write another method int[] make Move <b style="color: black;">(int[] oldBoard, int position) </b> that will take a board and a position, make a move from <br>
         that position, and return as its value a new board. (We could write this somewhat more efficiently by changing the old board, <br>
          rather than creating a new one, but here we are more concerned with simplicity.) In technical jargon, makeMove is "applicative" <br>
           rather than "mutative." <br>
           <br>
           Along with <b style="color: black;">canMove and makeMove,</b> we are using methods <b style="color: black;">puzzleSolved and printBoard</b> with meanings that <br>
           should be obvious.</span>        
  </p>
  <pre style="color: blue;">
    boolean solvable(int[] board) {
      ( if (puzzleSolved(board)) {
     
     return true;
     }
     for (int position 0; position BOARD SIZE; position++) {
     
     if (canMove(board, position)){
      ( int[] newBoard makeMove(board, position),
     
     if (solvable(newBoard)) {
     
     printBoard(newBoard);
     
     return true;
       }
      }
     }
     return false;
      }</pre>
      <span style="color: gray;">Along with canMove and makeMove, we are using methods puzzleSolved and printBoard with meanings that should be obvious. <br>
        Here is some output from the program:</span> <br>
        <i><font color="blue">16.</font>
        </i><b>WHITE WHITE WHITE _____ BLACK BLACK BLACK</b> <br>
        <i><font color="blue">15.</font>
        </i><b>WHITE WHITE WHITE BLACK _____ BLACK BLACK</b><br>
        <i><font color="blue">14.</font>
        </i><b>WHITE WHITE _____ BLACK WHITE BLACK BLACK</b><br>
        <i><font color="blue">13.</font>
        </i><b>WHITE _____ WHITE BLACK WHITE BLACK BLACK</b><br>
        <i><font color="blue">12.</font>
        </i><b>WHITE BLACK WHITE ______ WHITE BLACK BLACK</b><br>
        <i><font color="blue">11.</font>
        </i><b>WHITE BLACK WHITE BLACK WHITE _____ BLACK </b><br>
        <i><font color="blue">10.</font>
        </i><b>WHITE BLACK WHITE BLACK WHITE BLACK _____</b><br>
        <i><font color="blue">9.</font>
        </i><b>WHITE BLACK WHITE BLACK _____ BLACK WHITE</b><br>
        <i><font color="blue">8.</font>
        </i><b>WHITE BLACK _____ BLACK WHITE BLACK WHITE</b><br>
        <i><font color="blue">7.</font>
        </i><b>_____ BLACK WHITE BLACK WHITE BALCK WHITE</b><br>
        <i><font color="blue">6.</font>
        </i><b>BLACK _____ WHITE BLACK WHITE BLACK WHITE</b><br>
        <i><font color="blue">5.</font>
        </i><b>BLACK BLACK WHITE _____ WHITE BLACK WHITE</b><br>
        <i><font color="blue">4.</font>
        </i><b>BLACK BLACK WHITE BLACK WHITE _____ WHITE</b><br>
        <i><font color="blue">3.</font>
        </i><b>BLACK BLACK WHITE BLACK _____ WHITE WHITE </b><br>
        <i><font color="blue">2.</font>
        </i><b>BLACK BLACK _____ BLACK WHITE WHITE WHITE</b><br>
        <i><font color="blue">1.</font>
        </i><b>BLACK BLACK BLACK _____ WHITE WHITE WHITE</b><br>
        <br>
        <b style="color: gray;">Notice that the solution is given in reverse order: BLACK starts out on the left and WHITE on the right, as in the last <br>
           line. I've added line numbers to the actual output in order to emphasize this point. Backtracking always produces its <br>
            results (sequence of choices) in reverse order it is up to you, the programmer, to reverse the results again to get <br>
             them in the correct order.</b>
</body>

</html>